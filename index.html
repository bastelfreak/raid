<!DOCTYPE html>
<html>
  <head>
    <title>Raid - Was ist das und warum will ich das?</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(//fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(//fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(//fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);
         body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content h1 { font-size: 3em; }
      .remark-slide-content h2 { font-size: 2em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        -moz-border-radius: 5px;
        -web-border-radius: 5px;
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
        .left-column h2:last-of-type, .left-column h3:last-child {
          color: #000;
        }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      } 
      .right-column-center {
        width: 75%;
        float: right;
        padding-top: 1em;
				text-align: center;
      }
			.right-column img {
				width: 100%;
			}
		</style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Raid

---

# Agenda

1. Wer bin ich und warum ist Raid wichtig?
2. Allgemeine Definition
3. Raid Typen
4. Einsatzzweck
5. Implementierung
6. Fazit

---

class: middle, center

# Wer bin ich und warum ist Raid wichtig?

---

.left-column[
## Wer bin ich und warum ist Raid wichtig?
]
.right-column[
* Tests / Statistiken von über > 500.000 HDDs/SSDs erstellt

* Aufbau großer Setups mit viel Speicher (>2PB)

* Aufbau großer Setups mit vieeeeeeeeel IO Bedarf

* Erkenntnis 1: Datenträger gehen andauernd kaputt

* Erkenntnis 2: Datenträger können nicht schnell genug sein

* Zwangsweise mit Raid beschäftigt
]

---

class: middle, center

# Allgemeine Definition

---
.left-column[
## Allgemeine Definition
]
.right-column[
* Redundant Array of Independent Disks

* Redundant Array of Inexpensive Disks

* Logischer Zusammenschluss für mehr Leistung und Ausfallsicherheit

* Daten werden in Chunks/Stripes aufgeteilt

* Standard Chunk size von 64kB

* Größere Datein => größere Chunks
]

---
.left-column[
## Allgemeine Definition
### - Striping
]
.right-column[
* Nutzbarer Speicher [Kapazität der kleinsten Disk] * N

* N > 1

* Chunks werden gleichmäßig auf alle Datenträger verteilt

* Schreiben/Lesen kann parallel auf allen Datenträgern erfolgen

* Alle Daten verloren beim Ausfall eines Datenträgers

* Eigentlich gar kein Raid weil !Redundant
]

---
.left-column[
## Allgemeine Definition
### - Striping
]
.right-column[
![Right-aligned image](raid0.svg)
]

---

.left-column[
## Allgemeine Definition
### - Striping
### - Mirroring
]
.right-column[
* Nutzbarer Speicher [Kapazität der kleinsten Disk]

* N > 1

* Ein Chunk wird auf allen Disks gespeichert

* Lesen kann parallel auf allen Datenträgern erfolgen

* Das ist Raid :)
]

---

.left-column[
## Allgemeine Definition
### - Striping
### - Mirroring
]
.right-column[
![Right-aligned image](raid1.svg)
]

---

.left-column[
## Allgemeine Definition
### - Striping
### - Mirroring
### - Parity
]
.right-column[
* Nutzbarer Speicher [Kapazität der kleinsten Disk] * (N-1)

* N > 2

* Parallels Schreiben von N-1 Chunks (Paritychunk wird danach geschrieben)

* Paritychunk = XOR(N-1 Chunks)

* Lesen/Schreiben parallel auf allen Datenträgern

* Das ist auch noch Raid :)
]

---

.left-column[
## Allgemeine Definition
### - Striping
### - Mirroring
### - Parity
]
.right-column[
Update eines Chunks:

* Lesen des Chunks

* Vergleich ob neuer Chunk != alter Chunk

* Lesen des Parity Chunks

* neuer Paritychunk = XOR(alter Chunk + neuer Chunk + Parity Chunk)

* Schreiben vom neuen Chunk + neuer Paritychunk
]

---

.left-column[
## Allgemeine Definition
### - Striping
### - Mirroring
### - Parity
]
.right-column[
![right-aligned image](raid4.svg)
]

---

.left-column[
## Allgemeine Definition
### - Striping
### - Mirroring
### - Parity
]
.right-column[
![right-aligned image](raid5.svg)
]

---

.left-column[
## Allgemeine Definition
### - Striping
### - Mirroring
### - Parity
]
.right-column[
![Right-aligned image](raid6.svg)
]

---

.left-column[
## Einsatzzweck
]
.right-column-center[
## Ideen?
]
 
---

.left-column[
## Einsatzzweck Raidlevel
### - Raid 0
]
.right-column[
Vorteile:

* Hohe Schreib/Leseleistung

Nachteile:

* Kein Schutz vor Hardwaredefekten

Einsatzzweck:

* Speichern von OS/Spiele im Heimbereich
]

---

.left-column[
## Einsatzzweck Raidlevel
### - Raid 0
### - Raid 1
]
.right-column[
Vorteile:

* Hohe Leseleistung

* N-1 Disks können ausfallen ohne Datenverlust

Nachteile:

* Große Differenz zwischen Netto/Brutto Kapazität

Einsatzzweck:

* OS Installation im Server/Workstation Bereich

* Datenspeicher in Servern mit geringen Schreibanforderungen
]

---

.left-column[
## Einsatzzweck Raidlevel
### - Raid 0
### - Raid 1
### - Raid 4
]
.right-column[
Vorteile:

* erhöhte Schreib/Leseleistung

* Eine Disk kann ausfallen ohne Datenverlust

Nachteile:

* Parity Berechnung kostet Rechenleistung

* Ausfall Parity Disk => Neuberechnung Parity Chunks

* Starke Belastung aller verbliebenen Disks bei Rebuild

Einsatzzweck:

* Hohe Belastung beim Ausfall der Parity Disk => Garnicht
]

---

.left-column[
## Einsatzzweck Raidlevel
### - Raid 0
### - Raid 1
### - Raid 4
### - Raid 5
]
.right-column[
Vorteile:

* erhöhte Schreib/Leseleistung

* Eine Disk kann ausfallen ohne Datenverlust

Nachteile:

* Parity Berechnung kostet Rechenleistung

* Hohe Belastung aller verbliebenen Disks bei Rebuild

Einsatzzweck:

* Große Datenspeicher bis ~10TB mit geringen Random IO Anforderungen
]

---

.left-column[
## Einsatzzweck Raidlevel
### - Raid 0
### - Raid 1
### - Raid 4
### - Raid 5
### - Raid 6
]
.right-column[
Vorteile:

* erhöhte Schreib/Leseleistung

* Zwei Disks können ausfallen ohne Datenverlust

Nachteile:

* Parity Berechnung kostet Rechenleistung

* Hohe Belastung aller verbliebenen Disks bei Rebuild

Einsatzzweck:

* Große Datenspeicher bis ~19TB mit geringen Random IO Anforderungen
]

---

.left-column[
## Einsatzzweck Raidkombis
]
.right-column-center[
## Was kann man wohl wie kombinieren?
]

---

.left-column[
## Einsatzzweck Raidkombis
### - Raid 10
]
.right-column[
![right-aligned image](raid10.svg)
]

---

.left-column[
## Einsatzzweck Raidkombis
### - Raid 10
]
.right-column[
Vorteile:

* Hohe Schreib/Leseleistung

* Gute Skalierbarkeit

* Ausfall mehrerer Disks möglich

* Geringe Rebuildbelastung

* Sehr gute Random IO Leistung

Nachteile:

* Hoher Brutto/Netto Unterschied

Einsatzzweck:

* Virtualisierung

* Datenbanken

* Alles mit viel Random IO
]

---

.left-column[
## Einsatzzweck Raidkombis
### - Raid 10
### - Rest
]
.right-column[

* Raid 01

* Raid 50

* Raid 51

* Raid 60

* Raid 61
]

---
class: center, middle

## Hardware (RoC/Fakeraid)

## Software (mdadm/Dateisysteme)

---

.left-column[
## Hardware
### - RoC
]
.right-column[
![right-aligned image](lsi9271-4i.jpg)
]

---

.left-column[
## Hardware
### - RoC
]
.right-column[
## hier HBA foto einfügen
]


---

.left-column[
## Hardware
### - RoC
### - Fakeraid
]
.right-column[
* Raid Algorithmen gepsichert im Chipsatz(BiosRaid)

* Raid Algorithmen gespeichert auf Zusatzkarte(FakeRaid)

* Berechnungen übernimmt CPU, kein dedizierter Controller
]

---

.left-column[
## Software
### - mdadm
]
.right-column[
* Raid Algorithmen im Linux Kernel

* mdadm = **M**ultiple **D**isk **ADM**inistration

* mdadm => Userlandtool zum ansprechen der Algorithmen

* Verwaltung von X Blockdevices in einem Raidverbund
]

---

.left-column[
## Software
### - mdadm
]
.right-column[
Vorteile:

* Freie Implementierung der Algorithmen

* Raids sind unabhängig von Controller/CPU

Nachteile:

* Geringere Performance zu RoC bei Raidkombinationen (nur im HPC Bereich)

Einsatzzweck:

* Jeder Linux Server/Workstation (außer HPC)
]

---

.left-column[
## Software
### - mdadm
]
.right-column[
```
[root@bastelfreak-fs ~]# cat /proc/mdstat 
Personalities : [raid1] [raid6] [raid5] [raid4] 
md125 : active raid6 sda[4] sdd[7] sdi[8] sdg[2] sdf[3] 
      sdh[1] sde[0] sdc[6] sdb[5]
      20510945280 blocks super 1.2 level 6, 512k chunk, 
      algorithm 2 [9/9] [UUUUUUUUU]
      bitmap: 0/22 pages [0KB], 65536KB chunk

md126 : active raid1 sdj2[0] sdm2[3] sdl2[2] sdk2[1]
      1049536 blocks super 1.0 [4/4] [UUUU]
      bitmap: 1/1 pages [4KB], 65536KB chunk

md127 : active raid1 sdj1[0] sdm1[3] sdl1[2] sdk1[1]
      52510592 blocks super 1.2 [4/4] [UUUU]
      bitmap: 1/1 pages [4KB], 65536KB chunk

unused devices: <none>
[root@bastelfreak-fs ~]#```
]

---

.left-column[
## Software
### - mdadm
### - ZFS
]
.right-column[
Was ist das?

* **Z**ettabyte **F**ile **S**ystem von Sun

* Dateisystem inkl Volume Manager und Raid Support

* Konzipiert für den Enterprise Einsatz (Backupstorage mit >2PB, riesige Virtualisierungscluster)

* Funktioniert aber auch toll Zuhaus :)

* Entwickelt auf FreeBSD und Solaris

* Portierung auf Linux
]

---

.left-column[
## Software
### - mdadm
### - ZFS
]
.right-column[
Was kann ZFS als Dateisystem?

* Maximale Dateigröße von 16EiB (2^60)

* Maximale Dateisystemgröße 16EiB

* Maximal 2^48 Datein

* Transparente Komprimierung

* Transparente Verschlüsselung

* Dynamische Inodes

* Checksumming (CRC32)

* Scrubbing

* Deduplication

* Snapshots (CoW)
]

---

.left-column[
## Software
### - mdadm
### - ZFS
]
.right-column[
Was kann ZFS als Volume Manager?

* Partial Rebuild

* Send/Receive

* Pools mit dynamischen Partitionsgrößen

* Kein Write Hole bei Raid-Z1, Raid-Z2, Raid-Z3

* ZIL - ZFS Intent Log Cache (Ram oder Blockdevice[s])

* ARC - Adaptive Replacement Cache (Ram)

* L2ARC - Layer 2 Adaptive Replacement Cache (Ram oder Blockdevice[s])
]

---

.left-column[
## Software
### - mdadm
### - ZFS
### - BTRFS
]
.right-column[
Wie ZFS aber:

* Native Linux Entwicklung

* Keine eingebaute Verschlüsselung

* Online Raid Level Migration

* Unterschiedliche Raidlevel für Daten und Metadaten
]

---

.left-column[
## Software
### - mdadm
### - ZFS
### - BTRFS
### - glusterfs

]
.right-column[

]
---

.left-column[
## Software
### - mdadm
### - ZFS
### - BTRFS
### - glusterfs
### - ceph
]
.right-column[

]

---

class: middle, center

## Raid bietet mehr logischen Speicher, Ausfallsicherheit, gesteigerte IO Performance

## Raid ersetzt keine Backups!


			</textarea>
    <script src="remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
